- [基础](#basic)
  * [使用通配符的技巧](#useLike)
  * [正则表达式](#regularExpression)
  * [计算字段](#calculateFields)
  * [隔离级别](#isolationLevel)
- [设计](#Design)
  * [数据库范式](#NormalForm)
    + [第一范式](#1NF)
    + [第二范式](#2NF)
    + [第三范式](#3NF)
    + [反范式化](#NONF)
    + [范式化和反范式化的优缺点](#NF_NONF)
      - [范式化](#NF_1)
      - [反范式化](#NONF_1)
  * [MySQL逻辑架构](#mysqlArchi)
  * [Schema 与数据类型优化](#schema-optim)
    + [优化的数据类型](#optim-data-type)
    + [Schema设计](#schema-design)
  * [索引](#index)
    + [索引基础](#index-basic)
      - [索引类型](#index-type)
        * [B-Tree索引](#b-tree-index)
    + [索引的优点](#index-adv)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>

<a name="basic"></a>
# 基础
<a name="useLike"></a>
## 使用通配符的技巧

* 把通配符置于搜索模式的开始处，搜索起来是最慢的
<a name="regularExpression"></a>
## 正则表达式

* 区分大小写: REGEXP BINARY
* OR匹配：[123] = 1 | 2 | 3
* 匹配任意一个字符： '.000' 可以匹配 '1000', '2000', etc
* NOT匹配：[^123] = 匹配除这些字符以外的任何东西
* 匹配范围：[1 - 9]：匹配1-9任意一个数字，[a-z]：匹配a到z任意一个字母
* 转义：
  * "\\." 匹配 字符串中包含"."；
  * 多数正则表达式实现使用单个反斜杠转义特殊字符。MYSQL要求两个反斜杠（MUYSQL自己解释一个，正则表达式库解释另一个）
* 元字符

| 元字符  | 说明                        |
| ------- | --------------------------- |
| *       | 0个或多个匹配               |
| +       | 1个或多个匹配 (等于{1，})   |
| ?       | 0个或1个匹配 (等于{0，1})   |
| {n}     | 指定数目的匹配              |
| {n,}    | 不少于指定数目的匹配        |
| {n,m}   | 匹配数目的范围 (m不超过255) |
| ^       | 文本的开始                  |
| $       | 文本的结尾                  |
| [[:<:]] | 词的开始                    |
| [[:>:]] | 词的结尾                    |

<a name="calculateFields"></a>
## 计算字段

计算字段并不实际存在于数据库表中，计算字段是运行时在SELECT语句内创建的。

* 可在SQL语句内完成的许多转换和格式化工作都可以直接在Client应用程序内完成。但一般来说，在数据库服务器上完成这些操作比在Client中完成要快得多，因为DBMS是设计来快速有效地完成这种处理的
* 拼接字段：Concat()，把多个串连接起来形成一个较长的串；需要指定一个或多个指定的串，各个串之间用逗号分隔；多数DBMS使用+或| |来实现拼接，MYSQL使用Concat()函数来实现
* 使用别名：AS otherName

<a name="isolationLevel"></a>
## 隔离级别

* READ UNCOMMITTED（未提交读）
  * 事务中的修改，即使没有提交，对其他事务也是可见的。（脏读: Dirty Read）
* READ COMMITTED（提交读）
  * 一个事务从开始直到提交之前，所作的修改对其他事务是不可见的。也称为不可重复读（Nonrepeatable Read）
  * 大多数数据库系统的默认隔离级别都是READ COMMITTED（但MYSQL不是）
* REPEATABLE READ（可重复读）
  * 在同一个事务中多次读取同样记录的结果是一样的
  * 理论上无法解决幻读问题：当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读该范围的记录时，会产生幻行（Phantom Row）。InnoDB通过多版本并发控制（MVCC, Multiversion Concurrency Control）来解决幻读问题
  * MYSQL的默认隔离级别
* SERIZALIZABLE（可串行化）
  * 最高的隔离级别，强制事务串行执行
  * 在读取的每一行上加锁
  * 效率低

| 隔离级别         | 脏读可能性 | 不可重复度可能性 | 幻读可能性 | 加锁读 |
| ---------------- | ---------- | ---------------- | ---------- | ------ |
| READ UNCOMMITTED | Yes        | Yes              | Yes        | No     |
| READ COMMITTED   | No         | Yes              | Yes        | No     |
| REPEATABLE READ  | No         | No               | Yes        | No     |
| SERIZALIZABLE    | No         | No               | No         | Yes    |


<a name="Design"></a>
# 设计

<a name="NormalForm"></a>
## 数据库范式

<a name="1NF"></a>
### 第一范式

1NF对属性的**`原子性`**，要求属性具有原子性，不可再分解

> 表：字段1、 字段2(字段2.1、字段2.2)、字段3 ......

如学生（学号，姓名，性别，出生年月日），如果认为最后一列还可以再分成（出生年，出生月，出生日），它就不是一范式了，否则就是；

<a name="1NF"></a>
### 第二范式

2NF是对记录的**`惟一性`**，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；

> 表：学号、课程号、姓名、学分;

这个表明显说明了两个事务:学生信息, 课程信息;由于非主键字段必须依赖主键，这里**学分依赖课程号**，**姓名依赖与学号**，所以不符合二范式。

**可能会存在问题：**

- `数据冗余:`，每条记录都含有相同信息；
- `删除异常：`删除所有学生成绩，就把课程信息全删除了；
- `插入异常：`学生未选课，无法记录进数据库；
- `更新异常：`调整课程学分，所有行都调整。

**正确做法:**
学生：`Student`(学号, 姓名)；
课程：`Course`(课程号, 学分)；
选课关系：`StudentCourse`(学号, 课程号, 成绩)

<a name="3NF"></a>
### 第三范式

3NF是对字段的**`冗余性`**，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；

> 表: 学号, 姓名, 年龄, 学院名称, 学院电话

因为存在**依赖传递**: (学号) → (学生)→(所在学院) → (学院电话) 。

**可能会存在问题：**

- `数据冗余:`有重复值；
- `更新异常：`有重复的冗余信息，修改时需要同时修改多条记录，否则会出现**数据不一致的情况** 。

**正确做法：**

学生：(学号, 姓名, 年龄, 所在学院)；

学院：(学院, 电话)。

<a name="NONF"></a>
### 反范式化

**一般说来，数据库只需满足第三范式（`3NF`）就行了。**

没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余，**`达到以空间换时间的目的`**。

〖例〗：有一张存放商品的基本表，“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。

在`Rose 2002`中，规定列有两种类型：**数据列**和**计算列**。“金额”这样的列被称为“计算列”，而“单价”和“数量”这样的列被称为“数据列”。

<a name="NF_NONF"></a>
### 范式化和反范式化的优缺点
<a name="NF"></a>
#### 范式化

优点：

* 减少数据冗余
* 数据表更新快，体积小（可以更好地放在内存里，所以执行操作会更快）
* 很少有多余地数据意味着更少需要DISTINCT或者GROUP BY语句

缺点：

* 对于查询需要对多个表进行关联（导致性能降低）
* 更难进行索引优化

<a name="NONF_1"></a>
#### 反范式化

优点：不需要表地关联，对于大部分查询最差地情况，即使表没有使用索引，是全表扫描（全表扫描基本是顺序I/O）。当数据比内存大的时候，减少随机I/O。关联使得需要在一个索引中又排序又过滤（需要取关联表中检查，当符合要求的数据比较少的时候，效率比较低下）。使用反范式化组织数据，可以合并两表，将索引加到两个要查询排序的列上，就可以不用通过关联写出这个查询。

* 可以减少表的关联
* 可以更好的进行索引优化

缺点：

* 存在数据冗余及数据维护异常
* 对数据的修改需要更多成本



**对关联查询进行分解**

用分解关联查询的方式重构查询具有如下优势：

1. 让缓存的效率更高。 许多应用程序可以方便地缓存单表查询对应的结果对象。另外对于MySQL的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。
2. 将查询分解后，执行单个查询可以减少锁的竞争。
3. 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
4. 查询本身效率也可能会有所提升
5. 可以减少冗余记录的查询。
6. 更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套环关联，某些场景哈希关联的效率更高很多。

<a name="mysqlArchi"></a>
## MySQL逻辑架构

```shell
       客户端
   ↓   ↓   ↓   ↓
######服务器层########			
#  --连接/线程处理-- #
#      ↓        ↓   #	
#  查询缓存 ← 解析器 #   
#  	       ↓    #   
#  ----优化器----    #
#####################
------存储引擎层-------
|  □□□□□存储引擎□□□□□  |
---------------------
```

<a name="schema-optim"></a>
## Schema 与数据类型优化

<a name="optim-data-type"></a>
### 优化的数据类型

* 使用MySQL的内建类型而不是用字符串来存储日期和时间
* 当可为NULL的列被索引时，每个索引记录需要一个额外字节，如果计划在列上建索引，就应该尽量避免设计成可为NULL的列

<a name="schema-design"></a>
### Schema设计

* 太多列的坏处：MySQL<u>**存储引擎**</u>和<u>**服务器层**</u>之间先通过<u>**行缓存格式拷贝数据**</u>，然后在<u>**服务器层**</u>将缓存内容<u>**解码成各个列**</u>。从行缓冲中将编码过的列转换成行数据结构的操作代价非常高，<u>**转换的代价依赖于列的数量**</u>。 （而往往一些列并不会被用到）

* 太多关联：单个查询最好在12个表以内做关联

  
<a name="index"></a>
## 索引

索引（在MySQL中也叫做”键（key）“）是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。

索引能够轻易将查询性能提高几个数量级，”最优“的索引有时比一个”好的“索引性能要好两个数量级。

<a name="index-basic"></a>
### 索引基础

在MySQL中，存储引擎现在索引中找到对应的值，然后更具匹配的索引记录找到对应的数据行：

```sql
SELECT first_name FROM sakila.actor WHERE actor_id = 5
```

如果在actor_id列上建有索引，则MySQL将使用该索引找到actor_id为5的行，也就是说，MySQL先在索引上按值进行查找，然后返回所有包含该值的数据行。

```tips
@tips
索引可以包含一个或多个列的值。MySQL只能高效地使用索引地最左前缀列。创建一个包含两个列地索引，和创建两个只包含一列地索引是大不相同地
```

<a name="index-type"></a>
#### 索引类型

在MySQL中，索引是在存储引擎层而不是服务器层实现的：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引

<a name="b-tree-index"></a>
##### B-Tree索引


<a name="index-adv"></a>
### 索引的优点

主要作用：索引可以让服务器快速地定位到表的指定位置。

其他作用：

B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。总结索引三个优点如下：

* 索引大大减少了服务器需要扫描的数据量
* 索引可以帮助服务器避免排序和临时表
* 索引可以将随机I/O变为顺序I/O

**索引是最好的解决方案吗**

```tips
只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作室，索引才是有效的

* 对于非常小的表，大部分情况下简单的全表扫描更高效。
* 对于中到大型的表，索引就非常有效
* 对于特大型的表，建立和使用索引的代价将随之增长，这种情况下需要一种奇数可以直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配。例如可以使用分区技术
```



